__init__(self, args) # Вызывается при инициализации объекта
__add__() # добавить конкатенацию как в последовательность +
__len__(self) # добавить поддержку len()
__sub__() # добавить поддержку двухместного оператора -
__init__() # инициализация объекта
__repr__() # Настройка вывода репрезентативной формы.  Возвращает строку с репрезентативной формой представления x с использованием только символов набора ASCII ascii(x)
__eq__(self, other) # Как будет осуществлено x == y. По умолчанию экземпляры наших собственных классов поддерживают оператор == (который всегда возвращает False)
__lt__(self, other) # Как будет осуществлено x < y
__le__(self, other) # Как будет осуществлено x <= y
__ne__(self, other) # Как будет осуществлено x != y
__ge__(self, other) # Как будет осуществлено x >= y
__gt__(self, other) # Как будет осуществлено x > y
__new__(self) # Вызывается при создании объекта
__bool__(self) # Если реализован, возвращает значение истинности для x. Удобно, если используются конструкции вида if x:. То есть он всегда должен возвращать либо True, либо False.
__float__(self) # 
__invert__(self) # Логическое "НЕ" (битовое "НЕ" ~)
__and__(self) # Битовый и логический оператор И (&)
__or__(self) # соответствующий логическому оператору |
__ior__(self) # соответствующий комбинированному оператору присваивания |=
__iand__(self) # комбинированный операторприсваивания (&=)
__format__(self, format_spec) # Обеспечивает поддержку метода str.format() для классов существует так же format(x)
__hash__(self) # Если реализован, x сможет использоваться как ключ словаря или храниться в множестве
__str__(self) # Возвращает строковое представление x, пригодное для восприятия человеком
__rand__(self) # Этот метод вызывается в случае, когда объекты self и other принадлежат разным типам, а метод __and__() для данной пары типов не реализован. То есть возвращает значение NotImplemented.
__class__ # содержит ссылку на класс объекта
__del__(self) # вызывается при уничтожении объекта – по крайней мере в теории. По этой причине метод __del__() очень редко переопределяется он не должен использоваться для освобождения ресурсов, для закрытия файлов, сетевых соединений или подключений к базам данных.
__abs__(self) # 
__index__(self) # 
__pos__(self) #
__getitem__(self, k) # y[k] Возвращает kй элемент последовательности y или значение элемента с ключом k в отображении y
__setitem__(self, k, v) # y[k] = v Устанавливает kй элемент последовательности y или значение элемента с ключом k в отображении y
__delitem__(self, k) # del y[k] Удаляет kй элемент последовательности y или элемент с ключом k в отображении y
__contains__(self, x) # x in y, Возвращает True, если x присутствует в последовательности y или x является ключом отображения y
__iter__(self) # for x in y: pass Возвращает итератор по элементам последовательности y или по ключам отображения y
__reversed__(self) # reversed(y) Возвращает итератор, выполняющий обход элементов последовательности y или ключей отображения y в обратном порядке
__call__() # Каждая функция обладает этим методом. Если данный метод существует то значит функцию можно выполнить.
__getattr__(self, name) # obj.name  Данный метод срабатывает если объект вообще не имеет атрибута с именем name
__setattr__(self, name, value) # obj.name = value
__delattr__(self, name) # del obj.name
__dir__(self) # dir(obj) Возвращает список имен атрибутов объекта obj
__getattribute__(self, name) # obj.name Вызывается при первом же обращении к obj. Избежать рекурсии часто удается с помощью вызовов super().__getattribute__() или object.__getattribute__(). *Советуют не трогать этот метод, может постродать производительность